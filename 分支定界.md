Here we divide the $k$-defective clique into 2 parts——defective set and clique, so we try to search the defective set and then search the maximum clique from the common neighbors of the defective set.

***BranchBound***

**Input:** $P$, $C$, $X$

**Output:** None



***if JudgeDSetFull(P,C)***

​	$CN \leftarrow CommonNeighbor(P,C \cup X)$

​	$res \leftarrow MaxClique(\empty,CN)\cup P$

​	***return***

pick any vertex $v$ in $C$

$P \leftarrow P\cup \{v\}$, $C \leftarrow C\setminus \{v\}$

***BranchBound($P$, $C$, $X$)***

$C \leftarrow C\setminus \{v\}$, $X \leftarrow X \cup \{v\}$

***BranchBound($P$, $C$, $X$)***





注：设置4个集$P$, $C$, $CX$和$X$

degInP: 在P中的度数

degInC: 在C中的度数

degInCX: 在CX中的度数

degInG: 在G中的度数

***JudgeDSetFull(P,C)***

**Input:** $P$, $C$

**Output:** True/False

 

***if*** $|P|==2k$ ***or*** $r(P)==0$ ***or*** ($C==CN(P)\and isClique(C)$)//$C==CN(P)\and isClique(C)$表明已经不存在负边了

​	//$C==CN(P)\and isClique(C)$可用MEInPC==MEInP表示

***return*** True

***return*** False



$P$: defective set, 贡献了所有的缺边，通过枚举$P$来枚举所有的defective set(这种方法实际上枚举了所有$|D_{set}|\leq 2k$的defective set); 在进行了图分解后，实质上是对$v_i\cup D_{set}$进行枚举，可以分$v_i\in D_{set}$和$v_i\notin D_{set}$分情况讨论。

加速原则：

1. 加快$P$集合变满的速度
2. branch的时候减小$C$的大小
3. 求clqiue的时候减小Common neighbor的大小，即对$C\cup CX$剪枝

some branch cut rules:

1. if $|P|+|CN|\leq LB$, then cut the branch

将X集合分为X1和X2, X1是枚举过后的，X2是和P集合中的点互斥的

2. if $r(C\cup CX)\geq 0\ and\  |C\cup CX|\leq LB$, then cut the branch 

3. upperbound: 先对$CX$中的点染色，再对$C$中的点染色，注意如果选了$CX$中第$i$种颜色的点，则不能选$C$中第$i$种颜色的点，反之选了$C$中第$i$种颜色的点则不能选$CX$中第$i$种颜色的点（互斥$CX$中的点默认不会贡献负边）

   注：如果染色后有互斥关系则用DP还是可以的

4. 对于必须要加入$P$的点（这里所谓的必须加入是加入后一定不会让结果变差）的规则: if $deg_G(u)==|V_G|-2$, then we can move $u$ into $P$ without making the result worse.

5. if $deg_{P\cup C}(u)==|P\cup C|-1$, then we can move $u$ into $CX$.(把该点放入$P$不会比放入$CX$更好)

6. degree-sequence-based reduction rule: Given an instance $(G,P)$, let $v_1, v_2,...$ be an ordering of $V(G)\setminus P$ in non-decreasing order regarding their numbers of non-neighbors in $S$, i.e., $|\bar{N}_P (\cdot)|$. For a vertex $v_i$ with $i \gt LB-|P|$ and $|\bar{N}_P(v_i)| \gt k-|\overline{E}(P)|- \sum_{j=1}^{LB-|P|}|\overline{N}(v_j)|$, we can remove $v_i$ from $G$. 

7. degree&color-based reduction rule: Given an instance $(G,P)$, let $v_1, v_2,...$ be an ordering of  $V(G)\setminus P$ in non-decreasing order regarding $w(\cdot)$. For a vertex $v_i$ with $i \gt LB-|P|$ and $w(v_i) \gt k-|\overline{E}(P)|- \sum_{j=1}^{LB-|P|}w(v_j)$, we can remove $v_i$ from $G$. 
8. if $|P|==UB_P -1)$, move all $v\in C$ satisfying $N_P(v)==|P|$ into $CX$.
9. when **judgeDSetFull(P,C)==true**(马上要调用maxclique)，if $\exist u\in P$ such that $|N_P(u)|==|P|-1$, then we can return(这个剪枝包含了上一个剪枝)
10. for $v\in C$, if $N_P(v)==|P|$ and there is no vertex  $u$ in $C$ satisfies $\overline{E}(P\cup v \cup u)\leq k$ and $|\overline{N}_{P\cup v}(v)|<|P|+1$, then we can remove $v$ into $CX$.
11. If $\exist v\in P$ such that $|N_{P\cup C}(v)|=|P\cup C|-1$, then we can return.（This is true, because if there is $v$ then when judgeDSetFull(P,C)==true we must cut the branch)
12. The time complexity of the max-defective clique: 对于子图$S_i=G[v_i \cup N^+(v_i)\cup N^+_2(v_i)]$, 若从$N^+_2(v_i)$中挑选了$j$个点，则至多再从$N^+(v_i)$中选择$2k-2j$个点组成defective set, 之后对$N^+(v_i)$中剩下的至多$N^+(v_i)-(2k-2j)$个点求最大团，因此该种情况下最坏时间复杂度为$O(C_{D\Delta}^j C_{D}^{2k-2j} \gamma_{clq}^{D-2k+2j})$，因此所有情形的时间复杂度为$O(\sum_{j=0}^k (D\Delta)^j D^{2k-2j}\gamma_{clq}^{D-2k+2j})=O(\sum_{j=0}^k (D\Delta)^j (D\Delta)^{k-j}\gamma_{clq}^{D})=O(k(D\Delta)^k \gamma_{clq}^{D}) $, 其中$\gamma_{clq}$是调用的求解最大团算法时间复杂度多项式的根。
13. 问题：如果最后$|P|$中含有没有贡献缺边的点，如何避免重复枚举

注：枚举$P$的动机是为了枚举所有的defective set，$P$不等价于defective set，P集合的大小上界为$UB_P=min(2k+1,|P|+2(k-|\overline{E}(P)|))$



注：相似的idea也可以用于求极大$k$-defective clique
